#!/usr/bin/env python3\n\"\"\"\nSimple test for bulk import fix\n==============================\n\nThis script tests the bulk import functionality directly using the backend code.\n\"\"\"\n\nimport os\nimport sys\nimport logging\nfrom datetime import datetime\n\n# Add the backend directory to the Python path\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\n# Import necessary modules\ntry:\n    from backend import get_db, IS_PRODUCTION, DB_URL, auto_populate_seo_fields, ensure_unique_slug_failsafe, get_placeholder\nexcept ImportError:\n    print(\"‚ùå Could not import backend modules. Make sure you're in the correct directory.\")\n    sys.exit(1)\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\ndef test_postgresql_returning_insert():\n    \"\"\"Test the new PostgreSQL RETURNING insert method\"\"\"\n    logger.info(\"üß™ Testing PostgreSQL RETURNING insert method\")\n    \n    # Sample event data\n    test_event = {\n        'title': 'Test Bulk Import Fix',\n        'description': 'Testing the PostgreSQL RETURNING clause fix',\n        'date': '2025-06-10',\n        'start_time': '14:00',\n        'end_time': '16:00',\n        'category': 'test',\n        'address': '123 Test St, Test City, FL 32801',\n        'lat': 28.5383,\n        'lng': -81.3792,\n        'fee_required': 'Free',\n        'host_name': 'Test Organization',\n        'event_url': 'https://test.example.com'\n    }\n    \n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            \n            # Auto-populate SEO fields\n            event_dict = auto_populate_seo_fields(test_event)\n            logger.info(f\"‚úÖ SEO fields populated: slug={event_dict.get('slug')}, city={event_dict.get('city')}\")\n            \n            # Test slug generation\n            placeholder = get_placeholder()\n            base_slug = event_dict.get('slug', 'test-event')\n            unique_slug = ensure_unique_slug_failsafe(cursor, base_slug, placeholder)\n            event_dict['slug'] = unique_slug\n            logger.info(f\"‚úÖ Unique slug generated: {unique_slug}\")\n            \n            # Build insert query\n            insert_columns = ['title', 'description', 'date', 'start_time', 'end_time', 'category', 'address', 'lat', 'lng', 'slug', 'created_by', 'created_at']\n            insert_values = [\n                event_dict['title'],\n                event_dict['description'],\n                event_dict['date'],\n                event_dict['start_time'],\n                event_dict.get('end_time'),\n                event_dict['category'],\n                event_dict['address'],\n                event_dict['lat'],\n                event_dict['lng'],\n                event_dict['slug'],\n                1,  # Test user ID\n                datetime.utcnow().isoformat()\n            ]\n            \n            # Add optional fields if they exist\n            optional_fields = {\n                'fee_required': event_dict.get('fee_required'),\n                'host_name': event_dict.get('host_name'),\n                'event_url': event_dict.get('event_url'),\n                'city': event_dict.get('city'),\n                'state': event_dict.get('state'),\n                'country': event_dict.get('country', 'USA'),\n                'price': event_dict.get('price', 0.0)\n            }\n            \n            # Check which columns exist\n            try:\n                if IS_PRODUCTION and DB_URL:\n                    cursor.execute(\"\"\"\n                        SELECT column_name FROM information_schema.columns \n                        WHERE table_name = 'events' AND table_schema = 'public'\n                    \"\"\")\n                else:\n                    cursor.execute(\"PRAGMA table_info(events)\")\n                \n                if IS_PRODUCTION:\n                    available_columns = [row[0] for row in cursor.fetchall()]\n                else:\n                    available_columns = [row[1] for row in cursor.fetchall()]\n                \n                logger.info(f\"üìä Available columns: {len(available_columns)}\")\n                \n                # Add optional fields that exist in the database\n                for field, value in optional_fields.items():\n                    if field in available_columns and value is not None:\n                        insert_columns.append(field)\n                        insert_values.append(value)\n                \n            except Exception as e:\n                logger.warning(f\"‚ö†Ô∏è Could not check table schema: {e}\")\n            \n            # Test the RETURNING clause fix\n            event_id = None\n            if IS_PRODUCTION and DB_URL:\n                # PostgreSQL with RETURNING clause\n                placeholders = ', '.join(['%s'] * len(insert_values))\n                insert_query = f\"\"\"\n                    INSERT INTO events ({', '.join(insert_columns)}) \n                    VALUES ({placeholders})\n                    RETURNING id\n                \"\"\"\n                \n                logger.info(f\"üöÄ Testing PostgreSQL RETURNING insert with {len(insert_columns)} columns\")\n                cursor.execute(insert_query, insert_values)\n                \n                result = cursor.fetchone()\n                if result and result[0]:\n                    event_id = int(result[0])\n                    logger.info(f\"‚úÖ RETURNING clause worked! Event ID: {event_id}\")\n                else:\n                    logger.error(\"‚ùå RETURNING clause returned no result\")\n                    \n            else:\n                # SQLite with last_insert_rowid\n                placeholders = ', '.join(['?'] * len(insert_values))\n                insert_query = f\"\"\"\n                    INSERT INTO events ({', '.join(insert_columns)}) \n                    VALUES ({placeholders})\n                \"\"\"\n                \n                logger.info(f\"üöÄ Testing SQLite insert with {len(insert_columns)} columns\")\n                cursor.execute(insert_query, insert_values)\n                \n                cursor.execute(\"SELECT last_insert_rowid()\")\n                result = cursor.fetchone()\n                if result and result[0]:\n                    event_id = int(result[0])\n                    logger.info(f\"‚úÖ last_insert_rowid worked! Event ID: {event_id}\")\n                else:\n                    logger.error(\"‚ùå last_insert_rowid returned no result\")\n            \n            if event_id:\n                # Clean up test event\n                cursor.execute(\"DELETE FROM events WHERE id = \" + placeholder, (event_id,))\n                conn.commit()\n                logger.info(f\"üßπ Cleaned up test event {event_id}\")\n                return True\n            else:\n                logger.error(\"‚ùå Could not get event ID\")\n                return False\n                \n    except Exception as e:\n        logger.error(f\"‚ùå Test failed: {type(e).__name__}: {e}\")\n        return False\n\ndef test_slug_generation():\n    \"\"\"Test the slug generation function\"\"\"\n    logger.info(\"üß™ Testing slug generation function\")\n    \n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            placeholder = get_placeholder()\n            \n            # Test cases\n            test_cases = [\n                \"Test Event\",\n                \"Special Event with $pecial Characters!\",\n                \"Very Long Event Name That Should Be Truncated Properly\",\n                \"√©v√©nement fran√ßais\",  # Unicode test\n                \"\",  # Empty string test\n            ]\n            \n            for test_slug in test_cases:\n                try:\n                    result = ensure_unique_slug_failsafe(cursor, test_slug, placeholder)\n                    logger.info(f\"   '{test_slug}' -> '{result}'\")\n                except Exception as e:\n                    logger.error(f\"   ‚ùå '{test_slug}' failed: {e}\")\n            \n            return True\n            \n    except Exception as e:\n        logger.error(f\"‚ùå Slug test failed: {e}\")\n        return False\n\ndef test_database_connection():\n    \"\"\"Test basic database connection and info\"\"\"\n    logger.info(\"üß™ Testing database connection\")\n    \n    try:\n        with get_db() as conn:\n            cursor = conn.cursor()\n            \n            logger.info(f\"üìä Database info:\")\n            logger.info(f\"   IS_PRODUCTION: {IS_PRODUCTION}\")\n            logger.info(f\"   DB_URL set: {bool(DB_URL)}\")\n            logger.info(f\"   Database type: {'PostgreSQL' if IS_PRODUCTION and DB_URL else 'SQLite'}\")\n            \n            # Count existing events\n            cursor.execute(\"SELECT COUNT(*) FROM events\")\n            count = cursor.fetchone()[0]\n            logger.info(f\"   Current events: {count}\")\n            \n            return True\n            \n    except Exception as e:\n        logger.error(f\"‚ùå Database connection test failed: {e}\")\n        return False\n\ndef main():\n    \"\"\"Run all tests\"\"\"\n    logger.info(\"üöÄ Starting bulk import fix tests\")\n    \n    tests = [\n        (\"Database Connection\", test_database_connection),\n        (\"Slug Generation\", test_slug_generation),\n        (\"PostgreSQL RETURNING Insert\", test_postgresql_returning_insert)\n    ]\n    \n    passed = 0\n    total = len(tests)\n    \n    for test_name, test_func in tests:\n        logger.info(f\"\\nüìù Running: {test_name}\")\n        try:\n            if test_func():\n                logger.info(f\"‚úÖ {test_name} PASSED\")\n                passed += 1\n            else:\n                logger.error(f\"‚ùå {test_name} FAILED\")\n        except Exception as e:\n            logger.error(f\"‚ùå {test_name} ERROR: {e}\")\n    \n    logger.info(f\"\\nüìä Test Results: {passed}/{total} tests passed\")\n    \n    if passed == total:\n        logger.info(\"üéâ All tests PASSED! Bulk import fix is working correctly.\")\n    elif passed > 0:\n        logger.warning(f\"‚ö†Ô∏è Partial success: {passed}/{total} tests passed\")\n    else:\n        logger.error(\"‚ùå All tests FAILED\")\n        \n    return passed == total\n\nif __name__ == \"__main__\":\n    success = main()\n    sys.exit(0 if success else 1)\n 